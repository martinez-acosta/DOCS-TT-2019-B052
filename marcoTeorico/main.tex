
Del estado del arte se ha concluido que el modelo entidad-relación es el modelo conceptual más usado para describir modelos de datos NoSQL; también es de notar que ninguna herramienta de las estudiadas ofrece validación estructural de su modelo conceptual, obtención del esquema relacional o de las sentencias SQL.


En este apartado se muestran los diferentes conceptos con los que el lector debe estar relacionado para comprender la solución que se propone y el resto del capítulo está organizado de la siguiente manera: primero se muestran los modelos de datos para bases de datos, empezando con el modelo entidad-relación, donde está cómo interactúan entre sí sus elementos (entidades, atributos y relaciones) para representar una base de datos; después se expone el modelo relacional y una descripción de SQL (su lenguaje de consultas); también se muestra de forma concisa y breve los cuatro modelos de datos NoSQL (clave-valor, orientado a columnas, orientado a documentos y orientado a grafos); se explica cada tecnología usada en la propuesta de solución y el porqué ha sido elegida; finalmente, se termina con las conclusiones del capítulo.


\input{marcoTeorico/modelosDeDatos}
\input{marcoTeorico/modeloEntidadRelacion} 
\input{marcoTeorico/modeloRelacional}
\input{marcoTeorico/SQL} 
\input{marcoTeorico/modelosNoSQL}
\input{marcoTeorico/almacenamientoClaveValor}
\input{marcoTeorico/almacenamientoDocumentos}
\input{marcoTeorico/almacenamientoColumnas}
\input{marcoTeorico/almacenamientoGrafos}
\input{marcoTeorico/IngenieriaDirigidaPorModelos}
\input{marcoTeorico/DSL}
\input{marcoTeorico/M2M_M2T}


\section{Tecnologías a usar}
Para seleccionar las tecnologías a usar en las propuesta de solución se ha optado por investigar tecnologías similares y esta sección está organizado de la siguiente manera: primero se muestra cada tecnología usar; en caso de que sea la única opción se describirá qué es y en caso de que haya varias opciones, se explicará cada opción y se tendrá un apartado al final de cada comparación sobre la tecnología que se ha elegido.
\input{marcoTeorico/tecnologias_a_usar/http}
\input{marcoTeorico/tecnologias_a_usar/html}
\input{marcoTeorico/tecnologias_a_usar/css}
\input{marcoTeorico/tecnologias_a_usar/web_frameworks}
\input{marcoTeorico/tecnologias_a_usar/javascript_web_frameworks}
\input{marcoTeorico/tecnologias_a_usar/css_frameworks}
\input{marcoTeorico/tecnologias_a_usar/base_de_datos}
\input{marcoTeorico/tecnologias_a_usar/bibliotecas_diagramado}
\input{marcoTeorico/tecnologias_a_usar/python}
\input{marcoTeorico/tecnologias_a_usar/back_end}
\subsection{Herramientas para ingeniería dirigida por modelos}
De acuerdo con Kahani \cite{kahani_survey_2019}, en su estudio sobre unas 60 herramientas en la literatura del tema para desarrollar tranformaciones entre modelos, el 75 \% de las herramientas están hechas en Java\cite{joy_java_2000} y están implementadas como un \textit{plugin} del IDE Eclipse\cite{eclipse_eclipse_2009}. Igualmente, en las herramientas de otros lenguajes, por ejemplo, Python, aún no existe una integración entre transformaciones modelo a modelo y modelo a texto con la definición de gramáticas. 


Sin embargo, como PyEcore~\cite{pyecore_pyecore_2020} permite crear la definición de clases equivalentes en Python desde un archivo .ecore, se decidió usar PyEcore para implementar el modelo conceptual y lógico del modelo NoSQL.
% Metamodelo: ecore sirve para describir modelos, el modelo orientado a documentos y el orientado a columnas
% transformación modelo a modelo: xtend
% transformación modelo a texto: epsilon generation language
% Metamodelo GDM: xtext
\input{marcoTeorico/tecnologias_a_usar/ecore}
\input{marcoTeorico/tecnologias_a_usar/xtend}
\input{marcoTeorico/tecnologias_a_usar/egl}
\input{marcoTeorico/tecnologias_a_usar/xtext}
\input{marcoTeorico/conclusiones}