\subsection{Vue/Nuxt vs React vs AngularJS}
De acuerdo con la documentación de Vue.js\cite{noauthor_que_nodate}, Vue es un \textit{framework} progresivo para desarrollar interfaces de usuario. A diferencia de otros \textit{frameworks} monolíticos, Vue está diseñado desde cero para ser utilizado incrementalmente.


La librería central está enfocada solo en la capa de visualización y es fácil de utilizar e integrar con otras librerias o proyectos existentes. Por otro lado, Vue también es perfectamente capaz de impulsar sofisticadas \textit{single-page applications} cuando se utiliza en combinación con librerías de apoyo.


\subsubsection*{Comparación con React}

React y Vue comparten muchas similitudes; ambos utilizan un DOM virtual, proporcionan componentes de vista reactivos y componentes, mantienen el enfoque en la librería central, con temas como el enrutamiento y la gestión global del estado manejadas por librerías asociadas.


Tanto React como Vue ofrecen un rendimiento comparable en los casos de uso más comunes, con Vue normalmente un poco por delante debido a su implementación más ligera del DOM virtual.


En Vue, las dependencias de un componente se rastrean automáticamente durante su renderizado, por lo que el sistema sabe con precisión qué componentes deben volver a renderizarse cuando cambia el estado. Se puede considerar que cada componente tiene un \textit{shouldComponentUpdate} automáticamente implementado.


En general, esto elimina la necesidad de toda una clase de optimizaciones de rendimiento a los desarrolladores y les permite centrarse más en la construcción de la aplicación en sí misma a medida que va escalando.


Respecto al HTML, en React todo es únicamente JavaScript; no solo las estructuras HTML se expresan a través de JSX, sino que las tendencias recientes también apuntan a poner la gestión de CSS dentro de JavaScript.


En resumen, Vue adopta las tecnologías web clásicas.


\subsubsection*{Comparación con AngularJS}
Una buena parte de la sintaxis de Vue se verá muy similar a AngularJS (por ejemplo, v-if vs ng-if). Esto se debe a que hubo muchas cosas que AngularJS acertó y que fueron una inspiración para Vue desde etapas tempranas en su desarrollo.


Sin embargo, también hay muchos problemas que vienen con AngularJS, donde Vue ha intentado ofrecer una mejora significativa.


Vue es mucho más simple que AngularJS, tanto en términos de API como de diseño. Aprender lo suficiente para aplicaciones no triviales típicamente toma menos de un día, lo cual no es el caso para AngularJS.


AngularJS tiene una fuerte opinión sobre cómo deben estructurarse sus aplicaciones, mientras que Vue es una solución más flexible y modular. Aunque esto hace que Vue sea más adaptable a una amplia variedad de proyectos, también reconocemos que a veces es útil que algunas decisiones se tomen, para que el desarrollador se enfoque en programar.


Por eso Vue ofrece una plantilla webpack que puede configurarse en cuestión de minutos, a la vez que le permite acceder a funciones avanzadas como la recarga de módulos en marcha, \textit{linting} y extracción de CSS.


Vue tiene un mejor rendimiento y es más fácil de optimizar porque no utiliza la ``comprobación sucia”. 


AngularJS se vuelve lento cuando hay muchos \textit{watchers}, porque cada vez que algo cambia en el alcance, todos estos \textit{watchers} necesitan ser reevaluados de nuevo. Además, el ciclo \textit{digest} puede tener que ejecutarse varias veces para ``estabilizarse” si algún \textit{watcher} activa otra actualización.


Los usuarios de AngularJS a menudo tienen que recurrir a técnicas para sortear el ciclo \textit{digest} y, en algunas situaciones, no hay manera de optimizar un alcance con muchos \textit{watchers}.



Vue no sufre de esto en absoluto porque utiliza un sistema transparente de observación de seguimiento de dependencias con colas asíncronas - todos los cambios se activan de forma independiente a menos que tengan relaciones de dependencia explícitas.


\subsubsection*{Comparación con Angular}
En términos de rendimiento, ambos \textit{frameworks} son excepcionalmente rápidos y no hay suficientes datos de casos de uso en el mundo real para hacer un veredicto.


Vue es mucho menos intrusivo en las decisiones del desarrollador que Angular, ofreciendo soporte oficial para una variedad de sistemas de desarrollo, sin restricciones sobre cómo estructurar su aplicación. Muchos desarrolladores disfrutan de esta libertad, mientras que algunos prefieren tener solo una forma correcta de desarrollar cualquier aplicación.


Para empezar con Vue, todo lo que se necesita es familiarizarse con HTML y ES5 JavaScript; con estas habilidades básicas, se puede empezar a desarrollar aplicaciones no triviales.


La curva de aprendizaje de Angular es mucho más pronunciada. La superficie de la API del framework es enorme y como usuario necesitará familiarizarse con muchos más conceptos antes de ser productivo. La complejidad de Angular se debe en gran medida a su objetivo de diseño de apuntar solo a aplicaciones grandes y complejas - pero eso hace que el \textit{framework} sea mucho más difícil de entender para los desarrolladores con menos experiencia.

\subsubsection*{Nuxt.js}
De acuerdo a la documentación de Nuxt\cite{noauthor_what_nodate-1}, Nuxt.js es un \textit{framework} progresivo basado en Vue.js para crear aplicaciones web. Se basa en Vue.js y herramientas de desarrollo como webpack, Babel y PostCSS. El objetivo de Nuxt es hacer que el desarrollo web en Vue.js sea eficaz.

\paragraph*{Características}
\begin{enumerate}
    \item Escribir archivos Vue (*.vue)
    \item División automática de código
    \item Representación del lado del servidor
    \item Potente sistema de enrutamiento con datos asincrónicos
    \item Servicio de archivos estáticos
    \item Soporte sintaxis ES2015+ (Javascript ES6)
    \item Gestión del elemento <head> (<title>, <meta>, etc.)
    \item Preprocesador: Sass, Less, Stylus, etc.
\end{enumerate}


\subsubsection*{Conclusión}

Se usará Vue/Nuxt por ser el \textit{framework} con el que el equipo está más acostumbrado, además de ser el máx flexible de las opciones expuestas.